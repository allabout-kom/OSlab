## 练习1：理解内核启动中的程序入口操作

阅读 kern/init/entry.S内容代码，结合操作系统内核启动流程，说明指令 la sp, bootstacktop 完成了什么操作，目的是什么？ tail kern_init 完成了什么操作，目的是什么？
<div style="margin-left:2em;">
答：la sp, bootstacktop将标签 bootstacktop 的地址加载到寄存器 sp 中，目的是初始化栈指针寄存器sp 为指向内核启动栈的顶部，为栈分配内存空间。
<p></p>
kern_init是我们init.c中的函数，tail kern_init将代码跳转到 kern_init 函数，目的是传递控制权给 kern_init，开始执行内核代码。</div>

## 练习2: 使用GDB验证启动流程

为了熟悉使用 QEMU 和 GDB 的调试方法，请使用 GDB 跟踪 QEMU 模拟的 RISC-V 从加电开始，直到执行内核第一条指令（跳转到 0x80200000）的整个过程。通过调试，请思考并回答：RISC-V 硬件加电后最初执行的几条指令位于什么地址？它们主要完成了哪些功能？请在报告中简要记录你的调试过程、观察结果和问题的答案。
<div style="margin-left:2em;">
答：第一步对CPU进行最基础的硬件固化部分进行检查： 

```
0x1000: auipc	t0,0x0 # 将20位的立即数0x0符号扩展为32位，然后将其加到PC的高20位中，生成一个32位的地址，结果存储到寄存器 t0 中
0x1004:	addi	a1,t0,32 # 将寄存器 t0 的值加上立即数32，结果存储在寄存器 a1 中
0x1008:	csrr	a0,mhartid # 将控制和状态寄存器 mhartid 的值读取并保存当前处理器的 ID 到寄存器 a0 中
0x100c:	ld	t0,24(t0) # 从内存地址 t0 + 24 处加载一个64位的值到寄存器 t0 中，那个地址保存的值就是0x80000000
0x1010:	jr	t0 # 无条件跳转到寄存器 t0 中存储的地址
```

将断点打在0x1010处观测t0值，发现打断点时程序只显示Breakpoint 1 at 0x1010而没有对应的编程语句，侧面说明了说明该启动固件部分是由系统自动生成的机器指令，并非手动书写。<br>
正常观测出执行到这一步时寄存器t0的值为0x80000000。
<p></p>
下面，输入教程中提到的watch *0x80200000，再continue,发现左边终端成功输出(THU.CST) os is loading ...但是右边调试过程毫无反应。开始认为可能是赋值过程太快导致无法被观测，后来上网查询后，发现并非如此。<br>
在程序未运行前输入info files，发现部分结果如下：

```
Entry point: 0x80200000
0x80200000 - 0x802004c8 is .text
```
.text 段已经在0x80200000这个地址，内核被 ELF 静态映射到内存，CPU 没有执行 store操作，因此不会触发。<br>
不过此时观察t0寄存器的值可见：
```
(gdb) info r t0
t0             0x80200000       2149580800
```
证实PC值成功被设置为 0x80200000，跳转到操作系统内核的入口点，开始执行内核代码。
<p></p>
正常输入b *0x80200000,再输入continue,发现左侧终端并未进行任何输出，证实该过程未开始执行内核代码。继续continue,发现语句正常输出后进入死循环，验证实验完成。

</div>



    